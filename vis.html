<html>
<head>
    <title>CodeDNA</title>
    <link rel="stylesheet" href="vis.css" type="text/css" />
    <xlink href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
    <xscript type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js"></script>
    <xscript type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js"></script>
    <script type="text/javascript" src="../d3/d3.js?2.4.6"></script>
    <script type="text/javascript" src="../d3/d3.layout.js?2.4.6"></script>
    <script type="text/javascript" src="processed/git%253A%252F%252Fgithub.com%252FMobisocial%252Fdungbeetle.json"></script>
    <xscript type="text/javascript" src="processed/git%253A%252F%252Fgithub.com%252Fmbostock%252Fd3.json"></script>
    <xscript type="text/javascript" src="processed/git%253A%252F%252Fgithub.com%252Ftpurtell%252Fsocialbar.json"></script>
    <xscript type="text/javascript" src="processed/git%253A%252F%252Fgithub.com%252Ftpurtell%252Fwhoiswatching.json"></script>
</head>
<body>
    <script type="text/javascript">


var CodeA = 'a'.charCodeAt(0); 
var CodeZ = 'z'.charCodeAt(0); 
function computePosition(entry) {
    var word = entry.term;
    word = word.toLowerCase();
    while(word.length > 0 && (word.charCodeAt(0) < CodeA || word.charCodeAt(0) > CodeZ))
        word = word.substring(1);
    
    var min = 0;
    var max = 1;
    var lim = 1;
    for(var i = 0; i < word.length; ++i) {
        if(word.charCodeAt(i) < CodeA || word.charCodeAt(i) > CodeZ)
            continue;
        var slot = word.charCodeAt(i) - CodeA;
        var per_slot = (max - min) / (CodeZ - CodeA + 1);
        min += per_slot * slot;
        max =  min + per_slot;
        
        //hack for experiementing with number of subdivisions
        if(--lim == 0)
            break;
    }
    while(lim > 0) {
        max = min + (max - min) / (CodeZ - CodeA + 1);
        --lim;
    }
    entry.min = min;
    entry.max = max;
    entry.mid = (min + max) / 2;
    return entry;
}
    
var commit = 0;
var revisions = data.revisions;
var dates = data.dates;
var messages = data.messages;
var merged = data.merged;

var w = document.body.offsetWidth - 40,
    h = document.body.offsetHeight - 80,
    leftx = d3.scale.linear().domain([1, 0]).range([0, (w - 60) / 2]),
    lefty = d3.scale.linear().domain([0, 0.5]).range([0, h])
    rightx = d3.scale.linear().domain([0, 1]).range([w / 2 + 30, w]),
    righty = d3.scale.linear().domain([0.5, 1.0]).range([0, h])

var vis = d3.select("body")
  .append("svg:svg")
    .attr("width", w + 40)
    .attr("height", h + 80)
  .append("svg:g")
    .attr("transform", "translate(20,0)");


var rulesleft = vis.selectAll("g.ruleleft")
    .data(leftx.ticks(10))
  .enter().append("svg:g")
    .attr("class", "rule")
    .attr("transform", function(d) { return "translate(" + leftx(d) + ",0)"; });

rulesleft.append("svg:line")
    .attr("y1", h)
    .attr("y2", h + 6)
    .attr("stroke", "black");

rulesleft.append("svg:line")
    .attr("y1", 0)
    .attr("y2", h)
    .attr("stroke", "white")
    .attr("stroke-opacity", .3);


var rulesright = vis.selectAll("g.ruleright")
    .data(rightx.ticks(10))
  .enter().append("svg:g")
    .attr("class", "rule")
    .attr("transform", function(d) { return "translate(" + rightx(d) + ",0)"; });

rulesright.append("svg:line")
    .attr("y1", h)
    .attr("y2", h + 6)
    .attr("stroke", "black");

rulesright.append("svg:line")
    .attr("y1", 0)
    .attr("y2", h)
    .attr("stroke", "white")
    .attr("stroke-opacity", .3);
    
//rules.append("svg:text")
//    .attr("y", h + 9)
//    .attr("dy", ".71em")
//    .attr("text-anchor", "middle")
//    .text(x.tickFormat(10));

vis.append("svg:line")
    .attr("x1", leftx(0))
    .attr("x2", leftx(0))
    .attr("y1", 0)
    .attr("y2", h)
    .attr("stroke-width", 3)
    .attr("stroke", "black");

vis.append("svg:line")
    .attr("x1", rightx(0))
    .attr("x2", rightx(0))
    .attr("y1", 0)
    .attr("y2", h)
    .attr("stroke-width", 3)
    .attr("stroke", "black");
    
var letters = vis.selectAll("g.letters")
    .data(d3.range(0 + .5 / 26, 1 + .5 / 26, (1.0) / 26))
   .enter().append("svg:g")
    .attr("class", "rule");

letters.append("svg:text")
    .attr("x", leftx(0) + 10)
    .attr("x", function(d, i) {
        if(d > 0.499) {
            return rightx(0);
        } else {
            return leftx(0) + 10;
        }
    })
    .attr("y", function(d, i) {
        if(d > 0.499) {
            return righty(d);
        } else {
            return lefty(d);
        }
    })
    .attr("dx", -6)
    .attr("dy", ".35em")
    .attr("text-anchor", function(d, i) {
        if(d > 0.499) {
            return "end";
        } else {
            return "start";
        }
    })
    .text(function(d, i) { return String.fromCharCode(CodeA + i); });

var mintime = d3.min(revisions, function(c) { return dates[c]; });
var maxtime = d3.max(revisions, function(c) { return dates[c]; });

var timex = d3.scale.linear().domain([mintime, maxtime]).range([0,w]),
    timey = d3.scale.linear().domain([-1, 1]).range([h + 20, h + 80]);

vis.append("svg:line")
    .attr("y1", timey(0))
    .attr("y2", timey(0))
    .attr("x1", timex(mintime))
    .attr("x2", timex(maxtime))
    .attr("stroke", "black");
    
var timeline = vis.selectAll("g.timeline")
    .data(revisions)
   .enter().append("svg:g")
    .attr("class", "timeline");

var timeline_opacity = (w / 10) / revisions.length;
timeline.append("svg:circle")
    .attr("cx", function(d,i) {
        return timex(dates[d]);
    })
    .attr("cy", timey(0))
    .attr("r", 5)
    .attr("opacity", timeline_opacity)
    .attr("stroke", "black");

function isRightPane(d) {
    return d.min > 0.499;
}
    
function activateRevision(i) {
    commit = i;
    var max_score = 0;
    var rev = data.revisions[i];
    var words = data.words[rev];
    var items = [];
    for(var term in words) {
        items.push({term:term, count:words[term], score:words[term]});
    }
    items = items.filter(function(v) {
        return Math.abs(v.score) > 0 && v.term.length > 3;
    });
    items.map(function(i) {
        if(Math.abs(i.score) > max_score)
            max_score = Math.abs(i.score);
    });
    items = items.map(computePosition);
    items = items.map(function(d) { d.score /= max_score; d.score = Math.abs(d.score); return d;});

    vis.selectAll("g.bar").remove();

    var bars = vis.selectAll("g.bar")
        .data(items)
        .enter().append("svg:g")
        .attr("class", "bar");

    bars.append("svg:rect")
        .attr("fill", "steelblue")
        .attr("opacity", 0.3)
        .attr("x", function(d, i) { 
            if(isRightPane(d)) {
                return rightx(0);
            } else {
                return leftx(d.score); 
            }
        })
        .attr("y", function(d, i) { 
            if(isRightPane(d)) {
                return righty(d.min);
            } else {
                return lefty(d.min); 
            }
        })
        .attr("width", function(d, i) { 
            if(isRightPane(d)) {
                return Math.abs(rightx(d.score) - rightx(0)); 
            } else {
                return Math.abs(leftx(d.score) - leftx(0)); 
            }
        })
        .attr("height", function(d, i) { 
            if(isRightPane(d)) {
                return righty(d.max) - righty(d.min); 
            } else {
                return lefty(d.max) - lefty(d.min); 
            }
        });

    //bars.append("svg:text")
    //    .attr("x", x)
    //    .attr("y", y.rangeBand() / 2)
    //    .attr("dx", -6)
    //    .attr("dy", ".35em")
    //    .attr("fill", "white")
    //    .attr("text-anchor", "end")
    //    .text(x.tickFormat(100));

    //bars.append("svg:text")
    //    .attr("x", 0)
    //    .attr("y", y.rangeBand() / 2)
    //    .attr("dx", -6)
    //    .attr("dy", ".35em")
    //    .attr("text-anchor", "end")
    //    .text(function(d, i) { return String.fromCharCode(65 + i); });

}
function nextCommit() { 
    ++commit;
    commit = commit % revisions.length;
    activateRevision(commit);    
    setTimeout(nextCommit, 500);    
}
nextCommit();  
    </script>
</body>
</html>
